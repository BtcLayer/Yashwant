name: MetaStackerBandit VM Deployment

on:
  push:
    branches: [ main ]
  workflow_dispatch:  # Allow manual triggers

env:
  VM_HOST: 172.191.90.145
  VM_USER: azureuser
  VM_SSH_KEY: ${{ secrets.VM_SSH_PRIVATE_KEY }}
  PROJECT_DIR: /home/azureuser/MetaStackerBandit
  PYTHON_VERSION: '3.12'  # Use 3.12 on GitHub runners (stable wheels); VM still installs 3.13 if available

jobs:
  # Job 1: Build Frontend and Test
  build-and-test:
    runs-on: ubuntu-latest
    name: Build Frontend and Test

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python ${{ env.PYTHON_VERSION }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Cache pip dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-

    - name: Install Python dependencies
      run: |
        echo "üêç Python version: $(python --version)"
        python -m pip install --upgrade pip setuptools wheel
        # Install build dependencies first to ensure wheels can be built if needed
        pip install --only-binary :all: numpy pandas || pip install numpy pandas
        pip install -r requirements.txt

    - name: Test module imports
      run: |
        python -c "
        try:
            import live_demo.main
            print('‚úÖ live_demo.main imported')
        except Exception as e:
            print(f'‚ö†Ô∏è live_demo.main: {e}')
        try:
            import live_demo_1h.main
            print('‚úÖ live_demo_1h.main imported')
        except Exception as e:
            print(f'‚ö†Ô∏è live_demo_1h.main: {e}')
        try:
            import live_demo_12h.main
            print('‚úÖ live_demo_12h.main imported')
        except Exception as e:
            print(f'‚ö†Ô∏è live_demo_12h.main: {e}')
        try:
            import live_demo_24h.main
            print('‚úÖ live_demo_24h.main imported')
        except Exception as e:
            print(f'‚ùå live_demo_24h.main: {e}')
            exit(1)
        import requests
        print('‚úÖ All modules import successfully')
        "

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '22'  # Latest Node.js 22 LTS (2025)
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: Install frontend dependencies
      working-directory: ./frontend
      run: |
        echo "üì¶ Node.js version: $(node --version)"
        echo "üì¶ npm version: $(npm --version)"
        npm ci

    - name: Build React frontend (for testing)
      working-directory: ./frontend
      env:
        REACT_APP_API_URL: ''
        REACT_APP_DASHBOARD_PASSWORD: ${{ secrets.DASHBOARD_PASSWORD || 'metastacker2024' }}
      run: npm run build
      # Note: This build is just for testing. The actual build happens on VM.

  # Job 2: Deploy to Azure VM
  deploy-vm:
    runs-on: ubuntu-latest
    name: Deploy to Azure VM
    needs: build-and-test
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    environment: production

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup SSH
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.VM_SSH_PRIVATE_KEY }}" > ~/.ssh/vm_key
        chmod 600 ~/.ssh/vm_key
        ssh-keyscan -H ${{ env.VM_HOST }} >> ~/.ssh/known_hosts

    - name: Deploy to VM
      run: |
        ssh -i ~/.ssh/vm_key -o StrictHostKeyChecking=no ${{ env.VM_USER }}@${{ env.VM_HOST }} << EOF
        # Don't use set -e - we want to continue even if some commands fail
        # This allows the script to continue even if non-critical commands fail
        
        # Always start in project directory
        cd ${{ env.PROJECT_DIR }} || mkdir -p ${{ env.PROJECT_DIR }} && cd ${{ env.PROJECT_DIR }}
        
        # Check if repository exists, clone if not
        if [ ! -d ".git" ]; then
            echo "üì• Repository not found, cloning..."
            # Use GitHub Actions token for private repo access
            git clone https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git .
        else
            echo "üì• Pulling latest code..."
            # Configure git to use token for private repo
            git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git
            git fetch origin
        fi
        
        # Stash any local changes to data directories (safety measure)
        echo "üíæ Preserving bot data directories..."
        mkdir -p /tmp/vm_data_backup
        if [ -d "paper_trading_outputs" ]; then
            echo "   Backing up paper_trading_outputs..."
            cp -r paper_trading_outputs /tmp/vm_data_backup/ 2>/dev/null || true
        fi
        if [ -d "logs" ]; then
            echo "   Backing up logs..."
            cp -r logs /tmp/vm_data_backup/ 2>/dev/null || true
        fi
        
        # Clean up __pycache__ directories to avoid permission issues
        echo "üßπ Cleaning up Python cache directories..."
        find . -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true
        find . -type f -name "*.pyc" -delete 2>/dev/null || true
        find . -type f -name "*.pyo" -delete 2>/dev/null || true
        
        # Fix permissions on directories if needed
        echo "üîß Fixing directory permissions..."
        chmod -R u+w . 2>/dev/null || true
        
        # Reset code (but preserve untracked/ignored files)
        git reset --hard origin/main || {
            echo "‚ö†Ô∏è  git reset had issues, trying to fix permissions and retry..."
            find . -type d -name "__pycache__" -exec sudo rm -rf {} + 2>/dev/null || true
            sudo chown -R ${{ env.VM_USER }}:${{ env.VM_USER }} . 2>/dev/null || true
            git reset --hard origin/main
        }
        git clean -fd --exclude='paper_trading_outputs' --exclude='logs' --exclude='.env' || true
        
        # Restore data directories if they were backed up
        if [ -d "/tmp/vm_data_backup/paper_trading_outputs" ]; then
            echo "   Restoring paper_trading_outputs..."
            rm -rf paper_trading_outputs
            mv /tmp/vm_data_backup/paper_trading_outputs ./
        fi
        if [ -d "/tmp/vm_data_backup/logs" ]; then
            echo "   Restoring logs..."
            rm -rf logs
            mv /tmp/vm_data_backup/logs ./
        fi
        rm -rf /tmp/vm_data_backup
        
        echo "‚úÖ Code updated, bot data preserved"
        
        echo "üîß Installing system dependencies (if needed)..."
        export DEBIAN_FRONTEND=noninteractive
        sudo apt-get update -qq
        
        # Install Python 3.12 from deadsnakes PPA (Ubuntu 22.04 doesn't have 3.12 in default repos)
        echo "   Adding deadsnakes PPA for Python 3.12..."
        sudo apt-get install -y software-properties-common
        sudo add-apt-repository -y ppa:deadsnakes/ppa 2>/dev/null || {
            echo "   PPA already added or failed, continuing..."
        }
        sudo apt-get update -qq
        
        # Try to install Python 3.13 (latest 2025), fallback to 3.12, then 3.10
        if sudo apt-get install -y python3.13 python3.13-venv python3.13-distutils 2>/dev/null; then
            echo "‚úÖ Python 3.13 installed from deadsnakes PPA"
            PYTHON_VER="3.13"
        elif sudo apt-get install -y python3.12 python3.12-venv python3.12-distutils 2>/dev/null; then
            echo "‚úÖ Python 3.12 installed from deadsnakes PPA"
            PYTHON_VER="3.12"
        else
            echo "‚ö†Ô∏è  Python 3.13/3.12 not available, using system Python 3.10"
            sudo apt-get install -y python3 python3-venv
            PYTHON_VER="3"
        fi
        PYTHON_BIN=$(command -v python3.13 || command -v python3.12 || command -v python3)
        echo "üêç Python version on VM: $($PYTHON_BIN --version 2>/dev/null || echo 'unknown')"
        
        # Install other dependencies (fix Node.js/npm conflict by removing old packages first)
        echo "   Installing build tools and Node.js..."
        echo "   Removing conflicting Node.js packages..."
        sudo dpkg -r --force-all libnode72 2>/dev/null || true
        sudo apt-get purge -y nodejs npm libnode-dev libnode72 'libnode*' 2>/dev/null || true
        sudo apt-get autoremove -y 2>/dev/null || true
        sudo rm -rf /etc/apt/sources.list.d/nodesource.list /etc/apt/sources.list.d/nodesource.list.save 2>/dev/null || true
        sudo apt-get update -qq
        echo "   Installing Node.js 22.x LTS from NodeSource (latest 2025)..."
        curl -fsSL https://deb.nodesource.com/setup_22.x | sudo -E bash - || {
            echo "‚ö†Ô∏è  Node.js 22 setup failed, trying Node.js 20..."
            curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash - || {
                echo "‚ö†Ô∏è  NodeSource setup failed, falling back to Ubuntu nodejs..."
                sudo apt-get update -qq
            }
        }
        sudo apt-get install -y nodejs python3-pip build-essential git curl nginx
        sudo mkdir -p /var/log/nginx
        sudo chown ${{ env.VM_USER }}:${{ env.VM_USER }} /var/log/nginx
        mkdir -p logs
        touch logs/nginx-error.log logs/nginx-access.log
        sudo systemctl stop nginx 2>/dev/null || true
        sudo systemctl disable nginx 2>/dev/null || true
        echo "üì¶ Node.js version on VM: $(node --version)"
        echo "üì¶ npm version on VM: $(npm --version)"
        
        echo "üîÑ Setting up Python environment..."
        # Determine which Python to use (try 3.13, 3.12, then 3.10)
        USE_VENV=false
        if [ "$PYTHON_VER" = "3.13" ] && command -v python3.13 &> /dev/null; then
            PYTHON_CMD_VENV="python3.13"
        elif [ "$PYTHON_VER" = "3.12" ] && command -v python3.12 &> /dev/null; then
            PYTHON_CMD_VENV="python3.12"
        elif command -v python3.11 &> /dev/null; then
            PYTHON_CMD_VENV="python3.11"
        else
            PYTHON_CMD_VENV="python3"
        fi
        echo "üêç Using Python: $PYTHON_CMD_VENV ($($PYTHON_CMD_VENV --version 2>/dev/null || echo 'version check failed'))"
        PYTHON_CMD="python3"
        PIP_CMD="pip3"
        
        if [ ! -d "venv" ]; then
            echo "   Attempting to create virtual environment with $PYTHON_CMD_VENV..."
            if $PYTHON_CMD_VENV -m venv venv 2>/dev/null && [ -f "venv/bin/activate" ]; then
                echo "‚úÖ Virtual environment created"
                USE_VENV=true
            else
                echo "‚ö†Ô∏è  Virtual environment creation failed, using system Python"
                USE_VENV=false
            fi
        elif [ -f "venv/bin/activate" ]; then
            echo "‚úÖ Virtual environment already exists"
            USE_VENV=true
        else
            echo "‚ö†Ô∏è  Existing venv directory invalid, using system Python"
            USE_VENV=false
        fi
        
        if [ "$USE_VENV" = "true" ]; then
            echo "   Activating virtual environment..."
            source venv/bin/activate
            PYTHON_CMD="python"
            PIP_CMD="pip"
        else
            echo "   Using system Python (python3/pip3)"
            PYTHON_CMD="python3"
            PIP_CMD="pip3"
        fi
        # Safety guard in case activation failed
        PYTHON_CMD=${PYTHON_CMD:-python3}
        PIP_CMD=${PIP_CMD:-pip3}
        
        echo "üì¶ Updating Python dependencies..."
        # Upgrade pip (try with --user if permission denied)
        $PIP_CMD install -q --upgrade pip setuptools wheel 2>/dev/null || $PIP_CMD install -q --upgrade pip setuptools wheel --user 2>/dev/null || echo "‚ö†Ô∏è  pip upgrade failed, continuing..."
        # Install numpy and pandas first (they may need to build from source on some systems)
        echo "   Installing numpy and pandas (may take a few minutes)..."
        $PIP_CMD install -q numpy pandas 2>/dev/null || $PIP_CMD install -q numpy pandas --user 2>/dev/null || {
            echo "‚ö†Ô∏è  numpy/pandas install had issues, continuing with full requirements..."
        }
        # Install requirements (try with --user if permission denied)
        $PIP_CMD install -q -r requirements.txt 2>/dev/null || $PIP_CMD install -q -r requirements.txt --user 2>/dev/null || {
            echo "‚ùå Failed to install Python dependencies"
            echo "   Attempting with verbose output..."
            $PIP_CMD install -r requirements.txt --user || true
        }
        
        # Install Node.js dependencies and rebuild frontend
        echo "üì¶ Installing/updating Node.js dependencies..."
        cd frontend
        # Clean install to avoid "nodepath" and other module issues
        rm -rf node_modules package-lock.json 2>/dev/null || true
        npm cache clean --force 2>/dev/null || true
        npm install
        # Remove old build to ensure it's rebuilt with correct API URL
        echo "üßπ Removing old frontend build to force rebuild with correct API URL..."
        rm -rf build 2>/dev/null || true
        cd ..
        
        echo "üõë Stopping existing services..."
        # Kill processes by name
        pkill -9 -f "python.*start_project.py" 2>/dev/null || true
        pkill -9 -f gunicorn 2>/dev/null || true
        pkill -9 -f uvicorn 2>/dev/null || true
        pkill -9 -f run_unified_bots.py 2>/dev/null || true
        
        # Kill processes using port 8000 directly
        echo "   Freeing port 8000..."
        if command -v fuser &> /dev/null; then
            fuser -k 8000/tcp 2>/dev/null || true
        elif command -v lsof &> /dev/null; then
            lsof -ti:8000 | xargs kill -9 2>/dev/null || true
        else
            # Fallback: find and kill processes on port 8000
            for pid in $(ss -tlnp | grep :8000 | awk '{print $NF}' | cut -d',' -f2 | cut -d'=' -f2 | sort -u); do
                kill -9 "$pid" 2>/dev/null || true
            done
        fi
        
        # Wait for port to be released
        echo "   Waiting for port 8000 to be released..."
        for i in {1..10}; do
            if ! (ss -tlnp 2>/dev/null | grep -q :8000 || lsof -ti:8000 2>/dev/null); then
                echo "   ‚úÖ Port 8000 is free"
                break
            fi
            sleep 1
        done
        
        # Final check - if port still in use, try one more aggressive kill
        if ss -tlnp 2>/dev/null | grep -q :8000 || lsof -ti:8000 2>/dev/null; then
            echo "   ‚ö†Ô∏è  Port 8000 still in use, attempting final cleanup..."
            sudo fuser -k 8000/tcp 2>/dev/null || true
            sleep 2
        fi
        
        # Ensure necessary directories exist
        echo "üìÅ Creating necessary directories..."
        mkdir -p logs
        mkdir -p paper_trading_outputs/sheets_fallback
        
        echo "üöÄ Starting application with start_project.py..."
        # Ensure we're in the project directory
        cd ${{ env.PROJECT_DIR }}
        
        # Use start_project.py with production flags:
        # --gunicorn: Use gunicorn with multiple workers for production
        # --daemon: Run in background mode
        # Frontend will auto-rebuild if source files changed
        # Use the correct Python command (venv or system)
        # Ensure PYTHON_CMD is set (safety check)
        PYTHON_CMD=${PYTHON_CMD:-python3}
        echo "üêç Using Python command: $PYTHON_CMD"
        echo "üìÅ Working directory: $(pwd)"
        
        # Ensure logs directory exists
        mkdir -p logs
        
        # Verify port is free before starting
        if ss -tlnp 2>/dev/null | grep -q :8000 || lsof -ti:8000 2>/dev/null; then
            echo "‚ùå ERROR: Port 8000 is still in use after cleanup!"
            echo "   Attempting one more aggressive cleanup..."
            sudo fuser -k 8000/tcp 2>/dev/null || true
            sleep 3
            if ss -tlnp 2>/dev/null | grep -q :8000 || lsof -ti:8000 2>/dev/null; then
                echo "   ‚ùå Port 8000 still in use - deployment may fail"
                echo "   You may need to manually kill processes on port 8000"
            else
                echo "   ‚úÖ Port 8000 is now free"
            fi
        fi
        
        # Start the application - properly daemonize to survive SSH session closure
        echo "   Starting application..."
        
        # Ensure we're in the right directory and get absolute paths
        cd ${{ env.PROJECT_DIR }}
        PROJECT_ABS=$(pwd)
        LOG_FILE="$PROJECT_ABS/logs/start_project.log"
        mkdir -p "$PROJECT_ABS/logs"
        
        # Get absolute path to Python
        PYTHON_ABS=$(which "$PYTHON_CMD" || command -v "$PYTHON_CMD" || echo "$PYTHON_CMD")
        
        echo "   Project directory: $PROJECT_ABS"
        echo "   Python: $PYTHON_ABS"
        echo "   Log file: $LOG_FILE"
        
        # Use nohup with proper redirection and ensure complete detachment
        # The key is: nohup + redirect stdin + background + disown + setsid if available
        echo "   Starting with nohup (fully detached from SSH session)..."
        
        # Try to use setsid if available for complete session detachment
        # Use absolute path to Python and ensure we're in the right directory
        if command -v setsid &> /dev/null; then
            echo "   Using setsid for complete process detachment..."
            setsid nohup env PYTHONPATH="$PROJECT_ABS" "$PYTHON_ABS" start_project.py --gunicorn --daemon < /dev/null > "$LOG_FILE" 2>&1 &
            APP_PID=$!
        else
            # Fallback to just nohup
            nohup env PYTHONPATH="$PROJECT_ABS" "$PYTHON_ABS" start_project.py --gunicorn --daemon < /dev/null > "$LOG_FILE" 2>&1 &
            APP_PID=$!
        fi
        
        echo "   Started with PID: $APP_PID"
        
        # Immediately disown the process so it survives SSH session closure
        # This is critical - without disown, the process will be killed when SSH closes
        disown $APP_PID 2>/dev/null || {
            echo "   ‚ö†Ô∏è  Could not disown process $APP_PID"
        }
        
        # Verify the process is still running after a moment
        sleep 2
        if ps -p $APP_PID > /dev/null 2>&1; then
            echo "   ‚úÖ Process $APP_PID is running and disowned"
        else
            echo "   ‚ö†Ô∏è  Process $APP_PID exited quickly (may have started gunicorn and exited - this is normal)"
        fi
        
        echo "   Process started and will survive SSH session closure"
        
        # Give it time to start up - start_project.py --daemon returns immediately
        # but gunicorn workers take a few seconds to start
        echo "   Waiting for application to initialize..."
        echo "   (This may take 20-30 seconds for frontend build and gunicorn startup)"
        
        # Wait and check multiple times to ensure process stays alive
        STABLE_COUNT=0
        for wait_iter in {1..15}; do
            sleep 2
            # Check if gunicorn is running
            if pgrep -f "gunicorn.*main:app" > /dev/null 2>&1; then
                STABLE_COUNT=$((STABLE_COUNT + 1))
                if [ $STABLE_COUNT -ge 3 ]; then
                    echo "   ‚úÖ Gunicorn has been stable for $((STABLE_COUNT * 2)) seconds"
                    break
                fi
            else
                STABLE_COUNT=0
                if [ $wait_iter -lt 10 ]; then
                    echo "   ‚è≥ Still waiting for gunicorn to start... ($((wait_iter * 2))s)"
                fi
            fi
        done
        
        # Final wait to ensure everything is ready
        sleep 5
        
        # Check for the actual running processes (gunicorn workers are what matter)
        echo "   Checking for running processes..."
        
        # Check if our PID is still running
        if ps -p $APP_PID > /dev/null 2>&1; then
            echo "‚úÖ Parent process (PID: $APP_PID) is still running"
        else
            echo "‚ö†Ô∏è  Parent process (PID: $APP_PID) has exited (this is normal in daemon mode)"
        fi
        
        # Check for gunicorn master process
        GUNICORN_MASTER=$(pgrep -f "gunicorn.*main:app" | head -1 || echo "")
        GUNICORN_WORKERS=$(pgrep -f "gunicorn.*main:app" | wc -l || echo "0")
        
        # Check for start_project.py (should exit quickly in daemon mode)
        START_PROJECT_PIDS=$(pgrep -f "start_project.py" || echo "")
        
        if [ -n "$GUNICORN_MASTER" ]; then
            echo "‚úÖ Found gunicorn master process: $GUNICORN_MASTER"
            echo "‚úÖ Found $GUNICORN_WORKERS gunicorn worker process(es)"
        elif [ -n "$START_PROJECT_PIDS" ]; then
            echo "‚ö†Ô∏è  start_project.py is still running (may be starting gunicorn)..."
            echo "   PIDs: $START_PROJECT_PIDS"
        else
            echo "‚ùå No gunicorn processes found!"
            echo "   Checking logs for errors..."
            LOG_FILE="${{ env.PROJECT_DIR }}/logs/start_project.log"
            if [ -f "$LOG_FILE" ]; then
                echo "   Last 100 lines of log:"
                tail -100 "$LOG_FILE"
            else
                echo "   No log file found at $LOG_FILE - process definitely didn't start"
            fi
            echo "   Checking for any Python processes:"
            ps aux | grep -E "(python|gunicorn)" | grep -v grep || echo "   None found"
        fi
        
        # Verify port is now in use (means app started)
        echo "   Verifying port 8000 is listening..."
        sleep 5
        PORT_IN_USE=false
        PORT_CHECK_COUNT=0
        for i in {1..10}; do
            if ss -tlnp 2>/dev/null | grep -q :8000 || lsof -ti:8000 2>/dev/null; then
                PORT_IN_USE=true
                PORT_CHECK_COUNT=$i
                break
            fi
            sleep 2
        done
        
        DEPLOYMENT_SUCCESS=false
        
        if [ "$PORT_IN_USE" = "true" ]; then
            echo "‚úÖ Port 8000 is listening - application is running!"
            echo "   Verified after $PORT_CHECK_COUNT check(s)"
            
            # Try to actually hit the health endpoint
            echo "   Testing health endpoint..."
            if curl -f -s http://localhost:8000/api/health > /dev/null 2>&1; then
                echo "‚úÖ Health check passed - application is fully operational!"
                DEPLOYMENT_SUCCESS=true
            else
                echo "‚ö†Ô∏è  Health check failed, but port is listening (may still be starting)"
                # Give it one more chance
                sleep 5
                if curl -f -s http://localhost:8000/api/health > /dev/null 2>&1; then
                    echo "‚úÖ Health check passed on retry!"
                    DEPLOYMENT_SUCCESS=true
                else
                    echo "‚ùå Health check failed even after retry"
                fi
            fi
        else
            echo "‚ùå Port 8000 is NOT in use - application failed to start!"
        fi
        
        if [ "$DEPLOYMENT_SUCCESS" != "true" ]; then
            echo ""
            echo "   =========================================="
            echo "   ‚ùå DEPLOYMENT FAILED - Debugging Info"
            echo "   =========================================="
            echo ""
            echo "   Recent log output (last 100 lines):"
            LOG_FILE="${{ env.PROJECT_DIR }}/logs/start_project.log"
            if [ -f "$LOG_FILE" ]; then
                tail -100 "$LOG_FILE"
            else
                echo "   ‚ùå No log file found at $LOG_FILE"
            fi
            echo ""
            echo "   Running processes:"
            ps aux | grep -E "(python|gunicorn|start_project)" | grep -v grep || echo "   None found"
            echo ""
            echo "   Port 8000 status:"
            ss -tlnp 2>/dev/null | grep :8000 || echo "   Not listening"
            echo ""
            echo "   Gunicorn processes:"
            pgrep -af gunicorn || echo "   None found"
            echo ""
            echo "   =========================================="
            echo "   ‚ùå EXITING WITH ERROR - Deployment failed!"
            echo "   =========================================="
            exit 1
        fi
        
        echo ""
        echo "‚úÖ Deployment script complete - Application is running!"
        EOF

    - name: Verify Deployment
      run: |
        echo "üîç Verifying deployment..."
        sleep 10
        
        # Wait for app to start
        echo "‚è≥ Waiting for application to start..."
        sleep 15
        
        # Try health check with retries (give more time for start_project.py to build frontend)
        for i in {1..8}; do
          if ssh -i ~/.ssh/vm_key -o StrictHostKeyChecking=no ${{ env.VM_USER }}@${{ env.VM_HOST }} "curl -f -s http://localhost:8000/api/health > /dev/null 2>&1"; then
            echo "‚úÖ Health check passed!"
            break
          else
            echo "‚è≥ Health check attempt $i/8 failed, retrying in 10 seconds..."
            echo "   (start_project.py may be building frontend or starting services...)"
            sleep 10
          fi
        done
        
        # Final check - this must pass or workflow fails
        if ssh -i ~/.ssh/vm_key -o StrictHostKeyChecking=no ${{ env.VM_USER }}@${{ env.VM_HOST }} "curl -f -s http://localhost:8000/api/health > /dev/null 2>&1"; then
          echo "‚úÖ Application is healthy and ready!"
        else
          echo "‚ùå FINAL HEALTH CHECK FAILED!"
          echo ""
          echo "   Debugging information:"
          echo "   ====================="
          ssh -i ~/.ssh/vm_key -o StrictHostKeyChecking=no ${{ env.VM_USER }}@${{ env.VM_HOST }} "echo '   Checking processes:'; ps aux | grep -E '(python|gunicorn|start_project)' | grep -v grep || echo '   None found'; echo ''; echo '   Port 8000 status:'; ss -tlnp 2>/dev/null | grep :8000 || echo '   Not listening'; echo ''; echo '   Recent logs:'; tail -50 ${{ env.PROJECT_DIR }}/logs/start_project.log 2>/dev/null || echo '   No log file'"
          echo ""
          echo "   Check manually at: http://${{ env.VM_HOST }}:8000/api/health"
          echo "   Check logs: ssh ${{ env.VM_USER }}@${{ env.VM_HOST }} 'tail -f ${{ env.PROJECT_DIR }}/logs/start_project.log'"
          exit 1
        fi

    - name: Deployment Summary
      run: |
        echo "=========================================="
        echo "‚úÖ DEPLOYMENT COMPLETE!"
        echo "=========================================="
        echo ""
        echo "üåê APPLICATION URL:"
        echo "   http://${{ env.VM_HOST }}:8000"
        echo ""
        echo "üìã ACCESS POINTS:"
        echo "   - Frontend Dashboard: http://${{ env.VM_HOST }}:8000"
        echo "   - Backend API:        http://${{ env.VM_HOST }}:8000/api"
        echo "   - Health Check:       http://${{ env.VM_HOST }}:8000/api/health"
        echo ""
        echo "=========================================="
        
        # Create a summary for GitHub Actions UI
        echo "## üöÄ VM Deployment Complete!" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### üåê Application URL" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "[**http://${{ env.VM_HOST }}:8000**](http://${{ env.VM_HOST }}:8000)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### üìã Access Points" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "- **Frontend Dashboard:** [http://${{ env.VM_HOST }}:8000](http://${{ env.VM_HOST }}:8000)" >> $GITHUB_STEP_SUMMARY
        echo "- **Backend API:** [http://${{ env.VM_HOST }}:8000/api](http://${{ env.VM_HOST }}:8000/api)" >> $GITHUB_STEP_SUMMARY
        echo "- **Health Check:** [http://${{ env.VM_HOST }}:8000/api/health](http://${{ env.VM_HOST }}:8000/api/health)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "---" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Note:** The application may take 10-30 seconds to fully start after deployment." >> $GITHUB_STEP_SUMMARY

    - name: Wait for Bot Outputs
      run: |
        echo "‚è≥ Waiting for bots to generate initial outputs (90 seconds)..."
        sleep 90
        echo "‚úÖ Wait complete, checking for outputs..."

    - name: Download Paper Trading Outputs
      run: |
        echo "üì• Downloading paper_trading_outputs from VM..."
        
        # Create local directory for outputs
        mkdir -p paper_trading_outputs
        
        # Use tar over SSH to download the folder (most reliable method)
        # This creates a tar archive on the VM and streams it to local machine
        ssh -i ~/.ssh/vm_key -o StrictHostKeyChecking=no ${{ env.VM_USER }}@${{ env.VM_HOST }} \
          "cd ${{ env.PROJECT_DIR }} && tar -czf - paper_trading_outputs 2>/dev/null" \
          | tar -xzf - || {
          echo "‚ö†Ô∏è Could not download outputs (may not exist yet or directory is empty)"
          # Try to check if directory exists
          ssh -i ~/.ssh/vm_key -o StrictHostKeyChecking=no ${{ env.VM_USER }}@${{ env.VM_HOST }} \
            "test -d ${{ env.PROJECT_DIR }}/paper_trading_outputs && echo 'Directory exists' || echo 'Directory does not exist'" || true
        }
        
        # Check what we got
        if [ -d "./paper_trading_outputs" ]; then
          echo "‚úÖ Downloaded outputs structure:"
          find ./paper_trading_outputs -type f \( -name "*.jsonl.gz" -o -name "*.csv" -o -name "*.json" \) | head -30 || echo "   (no files found yet)"
          echo ""
          echo "üìä Top-level directory structure:"
          ls -la ./paper_trading_outputs/ 2>/dev/null | head -20 || echo "   (directory empty or not accessible)"
          echo ""
          echo "üìà Summary by timeframe:"
          for tf in 5m 1h 12h 24h; do
            if [ -d "./paper_trading_outputs/$tf" ]; then
              file_count=$(find "./paper_trading_outputs/$tf" -type f | wc -l)
              echo "   $tf: $file_count files"
            fi
          done
        else
          echo "‚ö†Ô∏è paper_trading_outputs directory not found on VM"
        fi

    - name: Upload Paper Trading Outputs as Artifact
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: paper_trading_outputs
        path: paper_trading_outputs/
        retention-days: 7
        if-no-files-found: warn

