name: MetaStackerBandit VM Deployment

on:
  push:
    branches: [ main ]
  workflow_dispatch:  # Allow manual triggers

env:
  VM_HOST: 172.191.90.145
  VM_USER: azureuser
  VM_SSH_KEY: ${{ secrets.VM_SSH_PRIVATE_KEY }}
  PROJECT_DIR: /home/azureuser/MetaStackerBandit
  PYTHON_VERSION: '3.10'  # Match VM Python version for compatibility

jobs:
  # Job 1: Build Frontend and Test
  build-and-test:
    runs-on: ubuntu-latest
    name: Build Frontend and Test

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python ${{ env.PYTHON_VERSION }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Cache pip dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-

    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    - name: Test module imports
      run: |
        python -c "
        try:
            import live_demo.main
            print('‚úÖ live_demo.main imported')
        except Exception as e:
            print(f'‚ö†Ô∏è live_demo.main: {e}')
        try:
            import live_demo_1h.main
            print('‚úÖ live_demo_1h.main imported')
        except Exception as e:
            print(f'‚ö†Ô∏è live_demo_1h.main: {e}')
        try:
            import live_demo_12h.main
            print('‚úÖ live_demo_12h.main imported')
        except Exception as e:
            print(f'‚ö†Ô∏è live_demo_12h.main: {e}')
        try:
            import live_demo_24h.main
            print('‚úÖ live_demo_24h.main imported')
        except Exception as e:
            print(f'‚ùå live_demo_24h.main: {e}')
            exit(1)
        import requests
        print('‚úÖ All modules import successfully')
        "

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: Install frontend dependencies
      working-directory: ./frontend
      run: npm ci

    - name: Build React frontend (for testing)
      working-directory: ./frontend
      env:
        REACT_APP_API_URL: ''
        REACT_APP_DASHBOARD_PASSWORD: ${{ secrets.DASHBOARD_PASSWORD || 'metastacker2024' }}
      run: npm run build
      # Note: This build is just for testing. The actual build happens on VM.

  # Job 2: Deploy to Azure VM
  deploy-vm:
    runs-on: ubuntu-latest
    name: Deploy to Azure VM
    needs: build-and-test
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    environment: production

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup SSH
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.VM_SSH_PRIVATE_KEY }}" > ~/.ssh/vm_key
        chmod 600 ~/.ssh/vm_key
        ssh-keyscan -H ${{ env.VM_HOST }} >> ~/.ssh/known_hosts

    - name: Deploy to VM
      run: |
        ssh -i ~/.ssh/vm_key -o StrictHostKeyChecking=no ${{ env.VM_USER }}@${{ env.VM_HOST }} << 'DEPLOY_SCRIPT'
        # Don't use set -e, handle errors explicitly
        set +e
        
        # Check if repository exists, clone if not
        if [ ! -d "${{ env.PROJECT_DIR }}/.git" ]; then
            echo "üì• Repository not found, cloning..."
            mkdir -p ${{ env.PROJECT_DIR }}
            cd ${{ env.PROJECT_DIR }} || exit 1
            # Use GitHub Actions token for private repo access
            git clone https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git . || {
                echo "‚ùå Git clone failed"
                exit 1
            }
        else
            echo "üì• Pulling latest code..."
            cd ${{ env.PROJECT_DIR }} || exit 1
            # Configure git to use token for private repo
            git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git || true
            git fetch origin || {
                echo "‚ö†Ô∏è  Git fetch failed, trying full reset..."
                git reset --hard origin/main || exit 1
            }
        fi
        
        # Stash any local changes to data directories (safety measure)
        echo "üíæ Preserving bot data directories..."
        mkdir -p /tmp/vm_data_backup
        if [ -d "paper_trading_outputs" ]; then
            echo "   Backing up paper_trading_outputs..."
            cp -r paper_trading_outputs /tmp/vm_data_backup/ 2>/dev/null || true
        fi
        if [ -d "logs" ]; then
            echo "   Backing up logs..."
            cp -r logs /tmp/vm_data_backup/ 2>/dev/null || true
        fi
        
        # Reset code (but preserve untracked/ignored files)
        git reset --hard origin/main || {
            echo "‚ùå Git reset failed"
            exit 1
        }
        git clean -fd --exclude='paper_trading_outputs' --exclude='logs' --exclude='.env' || true
        
        # Restore data directories if they were backed up
        if [ -d "/tmp/vm_data_backup/paper_trading_outputs" ]; then
            echo "   Restoring paper_trading_outputs..."
            rm -rf paper_trading_outputs
            mv /tmp/vm_data_backup/paper_trading_outputs ./
        fi
        if [ -d "/tmp/vm_data_backup/logs" ]; then
            echo "   Restoring logs..."
            rm -rf logs
            mv /tmp/vm_data_backup/logs ./
        fi
        rm -rf /tmp/vm_data_backup
        
        echo "‚úÖ Code updated, bot data preserved"
        
        echo "üîß Installing system dependencies (if needed)..."
        # Install Python 3.13 and required packages
        sudo apt-get update -qq
        sudo apt-get install -y python3.13 python3.13-venv python3-pip build-essential git curl || {
            echo "   Python 3.13 not available, installing Python 3.10+ and venv..."
            sudo apt-get install -y python3 python3-venv python3-pip build-essential git curl
        }
        
        # Install Node.js 18 (required for frontend build)
        echo "üì¶ Installing Node.js 18..."
        NODE_VERSION=""
        NPM_VERSION=""
        if command -v node &> /dev/null; then
            NODE_VERSION=$(node --version 2>/dev/null || echo "")
        fi
        if command -v npm &> /dev/null; then
            NPM_VERSION=$(npm --version 2>/dev/null || echo "")
        fi
        
        if [ -z "$NODE_VERSION" ] || [ -z "$NPM_VERSION" ] || [ "$(echo "$NODE_VERSION" | cut -d'v' -f2 | cut -d'.' -f1)" -lt 14 ]; then
            echo "   Installing Node.js 18 from NodeSource..."
            curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash - || {
                echo "‚ùå Failed to setup NodeSource repository"
                exit 1
            }
            sudo apt-get remove -y libnode-dev nodejs-doc libnode72 2>/dev/null || true
            sudo apt-get install -y nodejs || {
                echo "‚ùå Failed to install nodejs"
                exit 1
            }
        fi
        
        # Verify installations
        if ! command -v node &> /dev/null; then
            echo "‚ùå node command not found after installation"
            exit 1
        fi
        if ! command -v npm &> /dev/null; then
            echo "‚ö†Ô∏è  npm not found, trying to install separately..."
            sudo apt-get install -y npm || {
                echo "‚ùå Failed to install npm"
                exit 1
            }
        fi
        
        # Ensure npm is in PATH (find actual location)
        NODE_PATH=$(which node 2>/dev/null || echo "/usr/bin/node")
        NPM_PATH=$(which npm 2>/dev/null || echo "/usr/bin/npm")
        export PATH="$(dirname "$NODE_PATH"):$(dirname "$NPM_PATH"):$PATH"
        
        echo "‚úÖ Node.js $(node --version) installed at $NODE_PATH"
        echo "‚úÖ npm $(npm --version) installed at $NPM_PATH"
        
        echo "üîÑ Setting up Python environment..."
        # Try to create venv, but use system Python if it fails
        USE_VENV=false
        if [ ! -d "venv" ]; then
            echo "   Attempting to create virtual environment..."
            if python3 -m venv venv 2>/dev/null && [ -f "venv/bin/activate" ]; then
                echo "‚úÖ Virtual environment created"
                USE_VENV=true
            else
                echo "‚ö†Ô∏è  Virtual environment creation failed, using system Python"
                USE_VENV=false
            fi
        elif [ -f "venv/bin/activate" ]; then
            echo "‚úÖ Virtual environment already exists"
            USE_VENV=true
        else
            echo "‚ö†Ô∏è  Existing venv directory invalid, using system Python"
            USE_VENV=false
        fi
        
        if [ "$USE_VENV" = "true" ]; then
            echo "   Activating virtual environment..."
            source venv/bin/activate
            PYTHON_CMD="python"
            PIP_CMD="pip"
        else
            echo "   Using system Python (python3/pip3)"
            PYTHON_CMD="python3"
            PIP_CMD="pip3"
        fi
        
        echo "üì¶ Updating Python dependencies..."
        # Upgrade pip (try with --user if permission denied)
        $PIP_CMD install --upgrade pip setuptools wheel 2>/dev/null || $PIP_CMD install --upgrade pip setuptools wheel --user 2>/dev/null || echo "‚ö†Ô∏è  pip upgrade failed, continuing..."
        
        # Install requirements (try with --user if permission denied)
        echo "   Installing from requirements.txt..."
        PIP_LOG="/tmp/pip_install_$$.log"
        if $PIP_CMD install -r requirements.txt > "$PIP_LOG" 2>&1; then
            echo "‚úÖ Dependencies installed successfully"
        elif $PIP_CMD install -r requirements.txt --user > "$PIP_LOG" 2>&1; then
            echo "‚úÖ Dependencies installed with --user flag"
        else
            echo "‚ùå Failed to install Python dependencies"
            echo "   Last 20 lines of error log:"
            tail -20 "$PIP_LOG" || true
            echo "   Full log available at: $PIP_LOG"
            exit 1
        fi
        
        # Install Node.js dependencies if needed
        if [ ! -d "frontend/node_modules" ]; then
            echo "üì¶ Installing Node.js dependencies..."
            if ! command -v npm &> /dev/null; then
                echo "‚ùå npm not found, cannot install frontend dependencies"
                exit 1
            fi
            cd frontend || exit 1
            npm install || {
                echo "‚ùå npm install failed"
                cd ..
                exit 1
            }
            cd ..
        fi
        
        # Build frontend if not exists or if source changed
        echo "üì¶ Building frontend..."
        if [ ! -d "frontend/build" ] || [ ! -f "frontend/build/index.html" ]; then
            echo "   Frontend build missing, building now..."
            if ! command -v npm &> /dev/null; then
                echo "‚ùå npm not found, cannot build frontend"
                exit 1
            fi
            cd frontend || exit 1
            npm run build || {
                echo "‚ùå Frontend build failed"
                cd ..
                exit 1
            }
            cd ..
            echo "‚úÖ Frontend built successfully"
        else
            echo "‚úÖ Frontend build already exists"
        fi
        
        echo "üõë Stopping existing services..."
        pkill -f "python.*start_project.py" || true
        pkill -f gunicorn || true
        pkill -f uvicorn || true
        pkill -f run_unified_bots.py || true
        sleep 2
        
        # Ensure necessary directories exist
        echo "üìÅ Creating necessary directories..."
        mkdir -p logs
        mkdir -p paper_trading_outputs/sheets_fallback
        
        echo "üöÄ Starting application with start_project.py..."
        # Use start_project.py with production flags:
        # --gunicorn: Use gunicorn with multiple workers for production
        # --daemon: Run in background mode
        # --no-build: Skip frontend build (already built above)
        # Use the correct Python command (venv or system)
        # Add user-installed packages to PATH if using system Python
        
        # Build environment variables
        ENV_VARS=""
        if [ "$USE_VENV" != "true" ]; then
            # Find actual paths for user-installed packages
            USER_BIN="$HOME/.local/bin"
            ROOT_BIN="/root/.local/bin"
            USER_SITE=$(python3 -c "import site; print(site.USER_SITE)" 2>/dev/null || echo "$HOME/.local/lib/python3.10/site-packages")
            ROOT_SITE="/root/.local/lib/python3.10/site-packages"
            
            ENV_VARS="PATH=$ROOT_BIN:$USER_BIN:$PATH PYTHONPATH=$ROOT_SITE:$USER_SITE:\$PYTHONPATH"
        fi
        
        # Start application
        if [ -n "$ENV_VARS" ]; then
            nohup env $ENV_VARS $PYTHON_CMD start_project.py --gunicorn --daemon --no-build > logs/start_project.log 2>&1 &
        else
            nohup $PYTHON_CMD start_project.py --gunicorn --daemon --no-build > logs/start_project.log 2>&1 &
        fi
        
        APP_PID=$!
        echo "   Application started with PID: $APP_PID"
        sleep 3
        
        # Verify process is still running
        if ! ps -p $APP_PID > /dev/null 2>&1; then
            echo "‚ùå Application process died immediately"
            echo "   Last 30 lines of log:"
            tail -30 logs/start_project.log 2>/dev/null || echo "   No log file found"
            exit 1
        fi
        
        echo "‚úÖ Deployment complete!"
        DEPLOY_SCRIPT

    - name: Verify Deployment
      run: |
        echo "üîç Verifying deployment..."
        sleep 10
        
        # Wait for app to start
        echo "‚è≥ Waiting for application to start..."
        sleep 15
        
        # Try health check with retries
        HEALTH_CHECK_PASSED=false
        for i in {1..10}; do
          # Check if curl is available, if not try wget or python
          HEALTH_CMD="curl -f -s http://localhost:8000/api/health > /dev/null 2>&1 || python3 -c \"import urllib.request; urllib.request.urlopen('http://localhost:8000/api/health')\" > /dev/null 2>&1"
          
          if ssh -i ~/.ssh/vm_key -o StrictHostKeyChecking=no ${{ env.VM_USER }}@${{ env.VM_HOST }} "$HEALTH_CMD"; then
            echo "‚úÖ Health check passed on attempt $i!"
            HEALTH_CHECK_PASSED=true
            break
          else
            if [ $i -lt 10 ]; then
              echo "‚è≥ Health check attempt $i/10 failed, retrying in 10 seconds..."
              sleep 10
            fi
          fi
        done
        
        # Final check and status
        if [ "$HEALTH_CHECK_PASSED" = "true" ]; then
          echo "‚úÖ Application is healthy and ready!"
        else
          echo "‚ö†Ô∏è Health check failed after 10 attempts"
          echo "   Checking application status..."
          ssh -i ~/.ssh/vm_key -o StrictHostKeyChecking=no ${{ env.VM_USER }}@${{ env.VM_HOST }} "
            echo '=== Process Status ==='
            ps aux | grep -E '(start_project|gunicorn)' | grep -v grep || echo 'No processes found'
            echo ''
            echo '=== Port Status ==='
            ss -tuln | grep 8000 || netstat -tuln 2>/dev/null | grep 8000 || echo 'Port 8000 not listening'
            echo ''
            echo '=== Recent Logs ==='
            tail -30 ${{ env.PROJECT_DIR }}/logs/start_project.log 2>/dev/null || echo 'No logs found'
          " || true
          echo ""
          echo "   Manual check: http://${{ env.VM_HOST }}:8000/api/health"
        fi

    - name: Deployment Summary
      run: |
        echo "=========================================="
        echo "‚úÖ DEPLOYMENT COMPLETE!"
        echo "=========================================="
        echo ""
        echo "üåê APPLICATION URL:"
        echo "   http://${{ env.VM_HOST }}:8000"
        echo ""
        echo "üìã ACCESS POINTS:"
        echo "   - Frontend Dashboard: http://${{ env.VM_HOST }}:8000"
        echo "   - Backend API:        http://${{ env.VM_HOST }}:8000/api"
        echo "   - Health Check:       http://${{ env.VM_HOST }}:8000/api/health"
        echo ""
        echo "=========================================="
        
        # Create a summary for GitHub Actions UI
        echo "## üöÄ VM Deployment Complete!" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### üåê Application URL" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "[**http://${{ env.VM_HOST }}:8000**](http://${{ env.VM_HOST }}:8000)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### üìã Access Points" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "- **Frontend Dashboard:** [http://${{ env.VM_HOST }}:8000](http://${{ env.VM_HOST }}:8000)" >> $GITHUB_STEP_SUMMARY
        echo "- **Backend API:** [http://${{ env.VM_HOST }}:8000/api](http://${{ env.VM_HOST }}:8000/api)" >> $GITHUB_STEP_SUMMARY
        echo "- **Health Check:** [http://${{ env.VM_HOST }}:8000/api/health](http://${{ env.VM_HOST }}:8000/api/health)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "---" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Note:** The application may take 10-30 seconds to fully start after deployment." >> $GITHUB_STEP_SUMMARY

    - name: Wait for Bot Outputs
      run: |
        echo "‚è≥ Waiting for bots to generate initial outputs (90 seconds)..."
        sleep 90
        echo "‚úÖ Wait complete, checking for outputs..."

    - name: Download Paper Trading Outputs
      run: |
        echo "üì• Downloading paper_trading_outputs from VM..."
        
        # Create local directory for outputs
        mkdir -p paper_trading_outputs
        
        # Use tar over SSH to download the folder (most reliable method)
        # This creates a tar archive on the VM and streams it to local machine
        ssh -i ~/.ssh/vm_key -o StrictHostKeyChecking=no ${{ env.VM_USER }}@${{ env.VM_HOST }} \
          "cd ${{ env.PROJECT_DIR }} && tar -czf - paper_trading_outputs 2>/dev/null" \
          | tar -xzf - || {
          echo "‚ö†Ô∏è Could not download outputs (may not exist yet or directory is empty)"
          # Try to check if directory exists
          ssh -i ~/.ssh/vm_key -o StrictHostKeyChecking=no ${{ env.VM_USER }}@${{ env.VM_HOST }} \
            "test -d ${{ env.PROJECT_DIR }}/paper_trading_outputs && echo 'Directory exists' || echo 'Directory does not exist'" || true
        }
        
        # Check what we got
        if [ -d "./paper_trading_outputs" ]; then
          echo "‚úÖ Downloaded outputs structure:"
          find ./paper_trading_outputs -type f \( -name "*.jsonl.gz" -o -name "*.csv" -o -name "*.json" \) | head -30 || echo "   (no files found yet)"
          echo ""
          echo "üìä Top-level directory structure:"
          ls -la ./paper_trading_outputs/ 2>/dev/null | head -20 || echo "   (directory empty or not accessible)"
          echo ""
          echo "üìà Summary by timeframe:"
          for tf in 5m 1h 12h 24h; do
            if [ -d "./paper_trading_outputs/$tf" ]; then
              file_count=$(find "./paper_trading_outputs/$tf" -type f | wc -l)
              echo "   $tf: $file_count files"
            fi
          done
        else
          echo "‚ö†Ô∏è paper_trading_outputs directory not found on VM"
        fi

    - name: Upload Paper Trading Outputs as Artifact
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: paper_trading_outputs
        path: paper_trading_outputs/
        retention-days: 7
        if-no-files-found: warn

