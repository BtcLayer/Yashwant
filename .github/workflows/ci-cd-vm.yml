name: MetaStackerBandit VM Deployment

on:
  push:
    branches: [ main ]
  workflow_dispatch:  # Allow manual triggers

env:
  VM_HOST: 172.191.90.145
  VM_USER: azureuser
  VM_SSH_KEY: ${{ secrets.VM_SSH_PRIVATE_KEY }}
  PROJECT_DIR: /home/azureuser/MetaStackerBandit
  PYTHON_VERSION: '3.12'  # Use 3.12 on GitHub runners (stable wheels); VM still installs 3.13 if available

jobs:
  # Job 1: Build Frontend and Test
  build-and-test:
    runs-on: ubuntu-latest
    name: Build Frontend and Test

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python ${{ env.PYTHON_VERSION }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Cache pip dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-

    - name: Install Python dependencies
      run: |
        echo "üêç Python version: $(python --version)"
        python -m pip install --upgrade pip setuptools wheel
        # Install build dependencies first to ensure wheels can be built if needed
        pip install --only-binary :all: numpy pandas || pip install numpy pandas
        pip install -r requirements.txt

    - name: Test module imports
      run: |
        python -c "
        try:
            import live_demo.main
            print('‚úÖ live_demo.main imported')
        except Exception as e:
            print(f'‚ö†Ô∏è live_demo.main: {e}')
        try:
            import live_demo_1h.main
            print('‚úÖ live_demo_1h.main imported')
        except Exception as e:
            print(f'‚ö†Ô∏è live_demo_1h.main: {e}')
        try:
            import live_demo_12h.main
            print('‚úÖ live_demo_12h.main imported')
        except Exception as e:
            print(f'‚ö†Ô∏è live_demo_12h.main: {e}')
        try:
            import live_demo_24h.main
            print('‚úÖ live_demo_24h.main imported')
        except Exception as e:
            print(f'‚ùå live_demo_24h.main: {e}')
            exit(1)
        import requests
        print('‚úÖ All modules import successfully')
        "

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '22'  # Latest Node.js 22 LTS (2025)
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: Install frontend dependencies
      working-directory: ./frontend
      run: |
        echo "üì¶ Node.js version: $(node --version)"
        echo "üì¶ npm version: $(npm --version)"
        npm ci

    - name: Build React frontend (for testing)
      working-directory: ./frontend
      env:
        REACT_APP_API_URL: ''
        REACT_APP_DASHBOARD_PASSWORD: ${{ secrets.DASHBOARD_PASSWORD || 'metastacker2024' }}
      run: npm run build
      # Note: This build is just for testing. The actual build happens on VM.

  # Job 2: Deploy to Azure VM
  deploy-vm:
    runs-on: ubuntu-latest
    name: Deploy to Azure VM
    needs: build-and-test
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    environment: production

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup SSH
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.VM_SSH_PRIVATE_KEY }}" > ~/.ssh/vm_key
        chmod 600 ~/.ssh/vm_key
        ssh-keyscan -H ${{ env.VM_HOST }} >> ~/.ssh/known_hosts

    - name: Update Code on VM
      timeout-minutes: 5
      run: |
        ssh -i ~/.ssh/vm_key -o StrictHostKeyChecking=no ${{ env.VM_USER }}@${{ env.VM_HOST }} bash << 'UPDATE_EOF'
        set +e
        cd ${{ env.PROJECT_DIR }} || mkdir -p ${{ env.PROJECT_DIR }} && cd ${{ env.PROJECT_DIR }}
        
        if [ ! -d ".git" ]; then
            echo "üì• Repository not found, cloning..."
            git clone https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git .
        else
            echo "üì• Pulling latest code..."
            git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git
            timeout 120 git fetch origin || echo "‚ö†Ô∏è  Git fetch timed out"
        fi
        
        echo "üíæ Preserving bot data directories..."
        mkdir -p /tmp/vm_data_backup
        [ -d "paper_trading_outputs" ] && cp -r paper_trading_outputs /tmp/vm_data_backup/ 2>/dev/null || true
        [ -d "logs" ] && cp -r logs /tmp/vm_data_backup/ 2>/dev/null || true
        
        echo "üßπ Cleaning up Python cache..."
        find . -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true
        find . -type f -name "*.pyc" -delete 2>/dev/null || true
        
        echo "üîß Fixing permissions..."
        chmod -R u+w . 2>/dev/null || true
        
        echo "üîÑ Resetting to origin/main..."
        timeout 120 git reset --hard origin/main 2>&1 | head -50 || {
            find . -type d -name "__pycache__" -exec sudo rm -rf {} + 2>/dev/null || true
            sudo chown -R ${{ env.VM_USER }}:${{ env.VM_USER }} . 2>/dev/null || true
            timeout 120 git reset --hard origin/main 2>&1 | head -50 || echo "‚ö†Ô∏è  Git reset failed"
        }
        
        timeout 60 git clean -fd --exclude='paper_trading_outputs' --exclude='logs' --exclude='.env' 2>&1 | head -20 || true
        
        [ -d "/tmp/vm_data_backup/paper_trading_outputs" ] && rm -rf paper_trading_outputs && mv /tmp/vm_data_backup/paper_trading_outputs ./ || true
        [ -d "/tmp/vm_data_backup/logs" ] && rm -rf logs && mv /tmp/vm_data_backup/logs ./ || true
        rm -rf /tmp/vm_data_backup
        
        echo "‚úÖ Code updated"
        UPDATE_EOF

    - name: Install Dependencies on VM
      timeout-minutes: 10
      run: |
        ssh -i ~/.ssh/vm_key -o StrictHostKeyChecking=no ${{ env.VM_USER }}@${{ env.VM_HOST }} bash << 'DEPS_EOF'
        set +e
        cd ${{ env.PROJECT_DIR }}
        
        echo "üîß Installing system dependencies..."
        export DEBIAN_FRONTEND=noninteractive
        sudo apt-get update -qq
        
        sudo apt-get install -y software-properties-common
        sudo add-apt-repository -y ppa:deadsnakes/ppa 2>/dev/null || true
        sudo apt-get update -qq
        
        if sudo apt-get install -y python3.13 python3.13-venv python3.13-distutils 2>/dev/null; then
            PYTHON_VER="3.13"
        elif sudo apt-get install -y python3.12 python3.12-venv python3.12-distutils 2>/dev/null; then
            PYTHON_VER="3.12"
        else
            sudo apt-get install -y python3 python3-venv
            PYTHON_VER="3"
        fi
        
        sudo dpkg -r --force-all libnode72 2>/dev/null || true
        sudo apt-get purge -y nodejs npm libnode-dev libnode72 'libnode*' 2>/dev/null || true
        sudo apt-get autoremove -y 2>/dev/null || true
        sudo rm -rf /etc/apt/sources.list.d/nodesource.list* 2>/dev/null || true
        sudo apt-get update -qq
        
        curl -fsSL https://deb.nodesource.com/setup_22.x | sudo -E bash - || {
            curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash - || true
        }
        
        sudo apt-get install -y nodejs python3-pip build-essential git curl nginx
        sudo mkdir -p /var/log/nginx
        sudo chown ${{ env.VM_USER }}:${{ env.VM_USER }} /var/log/nginx
        mkdir -p logs
        sudo systemctl stop nginx 2>/dev/null || true
        sudo systemctl disable nginx 2>/dev/null || true
        
        echo "üîÑ Setting up Python environment..."
        USE_VENV=false
        if [ "$PYTHON_VER" = "3.13" ] && command -v python3.13 &> /dev/null; then
            PYTHON_CMD_VENV="python3.13"
        elif [ "$PYTHON_VER" = "3.12" ] && command -v python3.12 &> /dev/null; then
            PYTHON_CMD_VENV="python3.12"
        elif command -v python3.11 &> /dev/null; then
            PYTHON_CMD_VENV="python3.11"
        else
            PYTHON_CMD_VENV="python3"
        fi
        
        PYTHON_CMD="python3"
        PIP_CMD="pip3"
        
        if [ ! -d "venv" ]; then
            if $PYTHON_CMD_VENV -m venv venv 2>/dev/null && [ -f "venv/bin/activate" ]; then
                USE_VENV=true
            fi
        elif [ -f "venv/bin/activate" ]; then
            USE_VENV=true
        fi
        
        if [ "$USE_VENV" = "true" ]; then
            source venv/bin/activate
            PYTHON_CMD="python"
            PIP_CMD="pip"
        fi
        
        PYTHON_CMD=${PYTHON_CMD:-python3}
        PIP_CMD=${PIP_CMD:-pip3}
        
        echo "üì¶ Installing Python dependencies..."
        $PIP_CMD install -q --upgrade pip setuptools wheel 2>/dev/null || $PIP_CMD install -q --upgrade pip setuptools wheel --user 2>/dev/null || true
        $PIP_CMD install -q numpy pandas 2>/dev/null || $PIP_CMD install -q numpy pandas --user 2>/dev/null || true
        $PIP_CMD install -q -r requirements.txt 2>/dev/null || $PIP_CMD install -q -r requirements.txt --user 2>/dev/null || {
            $PIP_CMD install -r requirements.txt --user || true
        }
        
        echo "üì¶ Installing Node.js dependencies..."
        cd frontend
        rm -rf node_modules package-lock.json 2>/dev/null || true
        npm cache clean --force 2>/dev/null || true
        npm install
        rm -rf build 2>/dev/null || true
        cd ..
        
        echo "‚úÖ Dependencies installed"
        DEPS_EOF

    - name: Deploy and Start Application
      timeout-minutes: 10
      run: |
        ssh -i ~/.ssh/vm_key -o StrictHostKeyChecking=no -o ServerAliveInterval=60 ${{ env.VM_USER }}@${{ env.VM_HOST }} bash << 'START_EOF'
        # Don't use set -e - we want to continue even if some commands fail
        # This allows the script to continue even if non-critical commands fail
        set +e  # Explicitly disable exit on error
        
        set +e
        cd ${{ env.PROJECT_DIR }}
        
        echo "üõë Stopping existing services..."
        pkill -9 -f "python.*start_project.py" 2>/dev/null || true
        pkill -9 -f gunicorn 2>/dev/null || true
        pkill -9 -f uvicorn 2>/dev/null || true
        pkill -9 -f run_unified_bots.py 2>/dev/null || true
        sudo pkill -9 -f "python.*start_project.py" 2>/dev/null || true
        sudo pkill -9 -f gunicorn 2>/dev/null || true
        
        for port in 8000 8001; do
            sudo fuser -k ${port}/tcp 2>/dev/null || fuser -k ${port}/tcp 2>/dev/null || true
            sudo lsof -ti:${port} | xargs sudo kill -9 2>/dev/null || lsof -ti:${port} | xargs kill -9 2>/dev/null || true
            ss -tlnp 2>/dev/null | tail -n +2 | grep ":${port}" | awk '{print $NF}' | grep -oE 'pid=[0-9]+' | cut -d'=' -f2 | sort -u | while read pid; do
                [ -n "$pid" ] && [ "$pid" -gt 0 ] 2>/dev/null && (sudo kill -9 "$pid" 2>/dev/null || kill -9 "$pid" 2>/dev/null || true)
            done || true
        done
        
        for port in 8000 8001; do
            for i in {1..10}; do
                if ! (ss -tlnp 2>/dev/null | grep -q :${port} || lsof -ti:${port} 2>/dev/null); then
                    break
                fi
                sleep 1
            done
        done
        
        mkdir -p logs paper_trading_outputs/sheets_fallback
        
        PYTHON_CMD=$(command -v python || command -v python3 || echo "python3")
        cd ${{ env.PROJECT_DIR }}
        PROJECT_ABS=$(pwd)
        LOG_FILE="$PROJECT_ABS/logs/start_project.log"
        mkdir -p "$PROJECT_ABS/logs"
        PYTHON_ABS=$(which "$PYTHON_CMD" || command -v "$PYTHON_CMD" || echo "$PYTHON_CMD")
        
        cd "$PROJECT_ABS" || exit 1
        
        if command -v setsid &> /dev/null; then
            setsid nohup env PYTHONPATH="$PROJECT_ABS" "$PYTHON_ABS" start_project.py --gunicorn --daemon < /dev/null > "$LOG_FILE" 2>&1 &
            APP_PID=$!
        else
            nohup env PYTHONPATH="$PROJECT_ABS" "$PYTHON_ABS" start_project.py --gunicorn --daemon < /dev/null > "$LOG_FILE" 2>&1 &
            APP_PID=$!
        fi
        
        disown $APP_PID 2>/dev/null || true
        sleep 5
        
        STABLE_COUNT=0
        for wait_iter in {1..15}; do
            sleep 2
            if pgrep -f "gunicorn.*main:app" > /dev/null 2>&1; then
                STABLE_COUNT=$((STABLE_COUNT + 1))
                [ $STABLE_COUNT -ge 3 ] && break
            else
                STABLE_COUNT=0
            fi
        done
        
        sleep 5
        
        PORT_IN_USE=false
        for i in {1..10}; do
            if ss -tlnp 2>/dev/null | grep -q :8000 || lsof -ti:8000 2>/dev/null; then
                PORT_IN_USE=true
                break
            fi
            sleep 2
        done
        
        DEPLOYMENT_SUCCESS=false
        if [ "$PORT_IN_USE" = "true" ]; then
            if curl -f -s http://localhost:8000/api/health > /dev/null 2>&1; then
                DEPLOYMENT_SUCCESS=true
            else
                sleep 5
                curl -f -s http://localhost:8000/api/health > /dev/null 2>&1 && DEPLOYMENT_SUCCESS=true
            fi
        fi
        
        if [ "$DEPLOYMENT_SUCCESS" != "true" ]; then
            echo "‚ùå DEPLOYMENT FAILED"
            [ -f "$LOG_FILE" ] && tail -100 "$LOG_FILE" || echo "No log file"
            ps aux | grep -E "(python|gunicorn|start_project)" | grep -v grep || echo "No processes"
            ss -tlnp 2>/dev/null | grep :8000 || echo "Port 8000 not listening"
            exit 1
        fi
        
        echo "‚úÖ Deployment complete - Application is running!"
        START_EOF

    - name: Verify Deployment
      run: |
        echo "üîç Verifying deployment..."
        sleep 10
        
        # Wait for app to start
        echo "‚è≥ Waiting for application to start..."
        sleep 15
        
        # Try health check with retries (give more time for start_project.py to build frontend)
        for i in {1..8}; do
          if ssh -i ~/.ssh/vm_key -o StrictHostKeyChecking=no ${{ env.VM_USER }}@${{ env.VM_HOST }} "curl -f -s http://localhost:8000/api/health > /dev/null 2>&1"; then
            echo "‚úÖ Health check passed!"
            break
          else
            echo "‚è≥ Health check attempt $i/8 failed, retrying in 10 seconds..."
            echo "   (start_project.py may be building frontend or starting services...)"
            sleep 10
          fi
        done
        
        # Final check - this must pass or workflow fails
        if ssh -i ~/.ssh/vm_key -o StrictHostKeyChecking=no ${{ env.VM_USER }}@${{ env.VM_HOST }} "curl -f -s http://localhost:8000/api/health > /dev/null 2>&1"; then
          echo "‚úÖ Application is healthy and ready!"
        else
          echo "‚ùå FINAL HEALTH CHECK FAILED!"
          echo ""
          echo "   Debugging information:"
          echo "   ====================="
          ssh -i ~/.ssh/vm_key -o StrictHostKeyChecking=no ${{ env.VM_USER }}@${{ env.VM_HOST }} "echo '   Checking processes:'; ps aux | grep -E '(python|gunicorn|start_project)' | grep -v grep || echo '   None found'; echo ''; echo '   Port 8000 status:'; ss -tlnp 2>/dev/null | grep :8000 || echo '   Not listening'; echo ''; echo '   Recent logs:'; tail -50 ${{ env.PROJECT_DIR }}/logs/start_project.log 2>/dev/null || echo '   No log file'"
          echo ""
          echo "   Check manually at: http://${{ env.VM_HOST }}:8000/api/health"
          echo "   Check logs: ssh ${{ env.VM_USER }}@${{ env.VM_HOST }} 'tail -f ${{ env.PROJECT_DIR }}/logs/start_project.log'"
          exit 1
        fi

    - name: Deployment Summary
      run: |
        echo "=========================================="
        echo "‚úÖ DEPLOYMENT COMPLETE!"
        echo "=========================================="
        echo ""
        echo "üåê APPLICATION URL:"
        echo "   http://${{ env.VM_HOST }}:8000"
        echo ""
        echo "üìã ACCESS POINTS:"
        echo "   - Frontend Dashboard: http://${{ env.VM_HOST }}:8000"
        echo "   - Backend API:        http://${{ env.VM_HOST }}:8000/api"
        echo "   - Health Check:       http://${{ env.VM_HOST }}:8000/api/health"
        echo ""
        echo "=========================================="
        
        # Create a summary for GitHub Actions UI
        echo "## üöÄ VM Deployment Complete!" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### üåê Application URL" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "[**http://${{ env.VM_HOST }}:8000**](http://${{ env.VM_HOST }}:8000)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### üìã Access Points" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "- **Frontend Dashboard:** [http://${{ env.VM_HOST }}:8000](http://${{ env.VM_HOST }}:8000)" >> $GITHUB_STEP_SUMMARY
        echo "- **Backend API:** [http://${{ env.VM_HOST }}:8000/api](http://${{ env.VM_HOST }}:8000/api)" >> $GITHUB_STEP_SUMMARY
        echo "- **Health Check:** [http://${{ env.VM_HOST }}:8000/api/health](http://${{ env.VM_HOST }}:8000/api/health)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "---" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Note:** The application may take 10-30 seconds to fully start after deployment." >> $GITHUB_STEP_SUMMARY

    - name: Wait for Bot Outputs
      run: |
        echo "‚è≥ Waiting for bots to generate initial outputs (90 seconds)..."
        sleep 90
        echo "‚úÖ Wait complete, checking for outputs..."

    - name: Download Paper Trading Outputs
      run: |
        echo "üì• Downloading paper_trading_outputs from VM..."
        
        # Create local directory for outputs
        mkdir -p paper_trading_outputs
        
        # Use tar over SSH to download the folder (most reliable method)
        # This creates a tar archive on the VM and streams it to local machine
        ssh -i ~/.ssh/vm_key -o StrictHostKeyChecking=no ${{ env.VM_USER }}@${{ env.VM_HOST }} \
          "cd ${{ env.PROJECT_DIR }} && tar -czf - paper_trading_outputs 2>/dev/null" \
          | tar -xzf - || {
          echo "‚ö†Ô∏è Could not download outputs (may not exist yet or directory is empty)"
          # Try to check if directory exists
          ssh -i ~/.ssh/vm_key -o StrictHostKeyChecking=no ${{ env.VM_USER }}@${{ env.VM_HOST }} \
            "test -d ${{ env.PROJECT_DIR }}/paper_trading_outputs && echo 'Directory exists' || echo 'Directory does not exist'" || true
        }
        
        # Check what we got
        if [ -d "./paper_trading_outputs" ]; then
          echo "‚úÖ Downloaded outputs structure:"
          find ./paper_trading_outputs -type f \( -name "*.jsonl.gz" -o -name "*.csv" -o -name "*.json" \) | head -30 || echo "   (no files found yet)"
          echo ""
          echo "üìä Top-level directory structure:"
          ls -la ./paper_trading_outputs/ 2>/dev/null | head -20 || echo "   (directory empty or not accessible)"
          echo ""
          echo "üìà Summary by timeframe:"
          for tf in 5m 1h 12h 24h; do
            if [ -d "./paper_trading_outputs/$tf" ]; then
              file_count=$(find "./paper_trading_outputs/$tf" -type f | wc -l)
              echo "   $tf: $file_count files"
            fi
          done
        else
          echo "‚ö†Ô∏è paper_trading_outputs directory not found on VM"
        fi

    - name: Upload Paper Trading Outputs as Artifact
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: paper_trading_outputs
        path: paper_trading_outputs/
        retention-days: 7
        if-no-files-found: warn

